
# parsetab.py
# This file is automatically generated. Do not edit.
# pylint: disable=W,C,R
_tabversion = '3.10'

_lr_method = 'LALR'

_lr_signature = "leftDIVleft{(leftCHRleftCONCATnonassoc^nonassoc_CHR DIVIDEexpression : unary_expunary_exp : CHRexpression : expression expression %prec CONCATexpression : expression DIVIDE expression %prec DIVexpression : unary_exp '^' unary_exp subexpexpression : unary_exp '_' unary_exp superexpsuperexp : lambdasuperexp : '^' unary_expsubexp : lambdasubexp : '_' unary_expunary_exp : '(' expression ')' unary_exp : '{' expression '}' lambda :"
    
_lr_action_items = {'CHR':([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,],[3,3,-1,-2,3,3,-3,3,3,3,3,3,3,-13,-13,-11,-12,-5,-9,3,-6,-7,3,-10,-8,]),'(':([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,],[4,4,-1,-2,4,4,-3,4,4,4,4,4,4,-13,-13,-11,-12,-5,-9,4,-6,-7,4,-10,-8,]),'{':([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,],[5,5,-1,-2,5,5,-3,5,5,5,5,5,5,-13,-13,-11,-12,-5,-9,5,-6,-7,5,-10,-8,]),'$end':([1,2,3,6,12,13,14,15,16,17,18,20,21,23,24,],[0,-1,-2,-3,-4,-13,-13,-11,-12,-5,-9,-6,-7,-10,-8,]),'DIVIDE':([1,2,3,6,10,11,12,13,14,15,16,17,18,20,21,23,24,],[7,-1,-2,-3,7,7,-4,-13,-13,-11,-12,-5,-9,-6,-7,-10,-8,]),')':([2,3,6,10,12,13,14,15,16,17,18,20,21,23,24,],[-1,-2,-3,15,-4,-13,-13,-11,-12,-5,-9,-6,-7,-10,-8,]),'}':([2,3,6,11,12,13,14,15,16,17,18,20,21,23,24,],[-1,-2,-3,16,-4,-13,-13,-11,-12,-5,-9,-6,-7,-10,-8,]),'^':([2,3,14,15,16,],[8,-2,22,-11,-12,]),'_':([2,3,13,15,16,],[9,-2,19,-11,-12,]),}

_lr_action = {}
for _k, _v in _lr_action_items.items():
   for _x,_y in zip(_v[0],_v[1]):
      if not _x in _lr_action:  _lr_action[_x] = {}
      _lr_action[_x][_k] = _y
del _lr_action_items

_lr_goto_items = {'expression':([0,1,4,5,6,7,10,11,12,],[1,6,10,11,6,12,6,6,6,]),'unary_exp':([0,1,4,5,6,7,8,9,10,11,12,19,22,],[2,2,2,2,2,2,13,14,2,2,2,23,24,]),'subexp':([13,],[17,]),'lambda':([13,14,],[18,21,]),'superexp':([14,],[20,]),}

_lr_goto = {}
for _k, _v in _lr_goto_items.items():
   for _x, _y in zip(_v[0], _v[1]):
       if not _x in _lr_goto: _lr_goto[_x] = {}
       _lr_goto[_x][_k] = _y
del _lr_goto_items
_lr_productions = [
  ("S' -> expression","S'",1,None,None,None),
  ('expression -> unary_exp','expression',1,'p_unary','parser_rules.py',22),
  ('unary_exp -> CHR','unary_exp',1,'p_expression_chr','parser_rules.py',26),
  ('expression -> expression expression','expression',2,'p_expression_concat','parser_rules.py',30),
  ('expression -> expression DIVIDE expression','expression',3,'p_expression_div','parser_rules.py',35),
  ('expression -> unary_exp ^ unary_exp subexp','expression',4,'p_expression_super','parser_rules.py',39),
  ('expression -> unary_exp _ unary_exp superexp','expression',4,'p_expression_sub','parser_rules.py',43),
  ('superexp -> lambda','superexp',1,'p_superexp_lambda','parser_rules.py',47),
  ('superexp -> ^ unary_exp','superexp',2,'p_superexp_expr','parser_rules.py',51),
  ('subexp -> lambda','subexp',1,'p_subexp_lambda','parser_rules.py',55),
  ('subexp -> _ unary_exp','subexp',2,'p_subexp_expr','parser_rules.py',59),
  ('unary_exp -> ( expression )','unary_exp',3,'p_expression_grouped_par','parser_rules.py',63),
  ('unary_exp -> { expression }','unary_exp',3,'p_expression_grouped_brkt','parser_rules.py',67),
  ('lambda -> <empty>','lambda',0,'p_lambda','parser_rules.py',72),
]
